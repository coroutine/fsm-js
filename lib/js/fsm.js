// Generated by CoffeeScript 1.6.3
var FSM;

FSM = (function() {
  FSM.WILDCARD = "*";

  FSM.VALID_NAME = /^[$A-Z_][0-9A-Z_$]*$/i;

  FSM.NO_NAME_ERROR = "An event must have a name.";

  FSM.BAD_NAME_ERROR = "'name' must be a valid variable name";

  FSM.BAD_OPTIONS_ERROR = "Please make sure 'options' specifies a transition from one state to another";

  FSM.INITIAL_STATE_ERROR = "The initial state is not a valid state.";

  FSM.INVALID_CALLBACK_POSITION_ERROR = "The specified callback position is invalid.";

  FSM.EVENT_EXISTS_ERROR = "The specified event has already been defined.";

  FSM.EVENT_DOES_NOT_EXIST_ERROR = "Cannot register a callback on a nonexistent event";

  FSM.prototype.events = [];

  FSM.prototype.callbacks = {
    before: {},
    after: {}
  };

  function FSM(options) {
    if (options == null) {
      options = {};
    }
    if (!_(options['states']).contains(options['initialState'])) {
      throw FSM.INITIAL_STATE_ERROR;
    }
    this.currentState = options['initialState'];
    this.states = options['states'];
  }

  FSM.prototype.state = function() {
    return this.currentState;
  };

  FSM.prototype.event = function(name, options) {
    var from, to, transition,
      _this = this;
    if (!name) {
      throw FSM.NO_NAME_ERROR;
    }
    if (!name.match(FSM.VALID_NAME)) {
      throw FSM.BAD_NAME_ERROR;
    }
    if (!this.eventOptionsAreValid(options)) {
      throw FSM.BAD_OPTIONS_ERROR;
    }
    if (_(this.events).contains(name)) {
      throw FSM.EVENT_EXISTS_ERROR;
    }
    transition = options['transition'];
    from = _([transition['from']]).flatten();
    to = transition['to'];
    this[name] = function() {
      if (!_(from).contains(_this.currentState)) {
        throw "Cannot transition to " + to + ", from " + _this.currentState;
      }
      _this.invokeCallbacks('before', name);
      _this.currentState = to;
      _this.invokeCallbacks('after', name);
      return _this;
    };
    this.events.push(name);
    return this;
  };

  FSM.prototype.before = function(name, callback) {
    return this.enqueueCallback('before', name, callback);
  };

  FSM.prototype.after = function(name, callback) {
    return this.enqueueCallback('after', name, callback);
  };

  FSM.prototype.enqueueCallback = function(position, name, callback) {
    var collection, names;
    if (!_(_(this.callbacks).keys()).contains(position)) {
      throw FSM.INVALID_CALLBACK_POSITION_ERROR;
    }
    if (!(_(this.events).contains(name) || name === FSM.WILDCARD)) {
      throw FSM.EVENT_DOES_NOT_EXIST_ERROR;
    }
    if (callback) {
      names = name === FSM.WILDCARD ? this.events : [name];
      collection = this.callbacks[position];
      _(names).each(function(evt) {
        var queue;
        queue = (collection[evt] || (collection[evt] = []));
        return queue.push(callback);
      });
    }
    return this;
  };

  FSM.prototype.invokeCallbacks = function(position, name) {
    return _(this.callbacks[position][name]).each(function(cb) {
      return cb();
    });
  };

  FSM.prototype.eventOptionsAreValid = function(options) {
    var from, fromHasElements, fromInStates, to, toInStates, toIsString, transition;
    transition = options != null ? options['transition'] : void 0;
    from = _(_([transition != null ? transition['from'] : void 0]).flatten()).compact();
    fromHasElements = !!from.length;
    fromInStates = _(this.states).intersection(from).length === from.length;
    to = transition != null ? transition['to'] : void 0;
    toIsString = _(to).isString();
    toInStates = _(this.states).contains(to);
    return !!(options && transition && fromHasElements && fromInStates && to && toIsString && toInStates);
  };

  return FSM;

})();
